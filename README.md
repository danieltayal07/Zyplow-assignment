# Next.js Demo app with Redis Caching

This project demonstrates a Next.js blog application that fetches data from an API (`https://dummyjson.com/posts`) and implements Redis caching to improve performance and reduce API requests. The application showcases both client-side and server-side rendering and provides a scalable architecture.

## Overview

The application is built using Next.js, a React framework that provides features such as server-side rendering, static site generation, and API routes.  Data is fetched from the `dummyjson` API, which provides sample blog post data.  To improve performance, the fetched data is cached in a Redis database, which is a fast, in-memory data store.  The application uses a time-to-live (TTL) value to expire the cached data after a specified duration, ensuring that the data remains fresh.

## Project Structure

The project structure is organized as follows:

```
demo1/
├── .next/                # Next.js build output directory
├── app/                  # Application directory
│   ├── api/              # API routes
│   │   └── posts/        # Posts API route
│   │       └── route.js  # Route handler for fetching posts
│   ├── client/           # Client components
│   │   └── page.js       # Client component that renders posts
│   └── page.js           # Server component that renders posts
├── lib/                  # Utility library
│   └── redis.js          # Redis client and connection logic
├── jsconfig.json         # JavaScript configuration file
├── next.config.js        # Next.js configuration file
├── package-lock.json     # npm package lock file
├── package.json          # npm package file
├── postcss.config.js     # PostCSS configuration file
└── README.md             # Project documentation (this file)
```



*   **`.next/`**: This directory contains the build output generated by Next.js. It is automatically created during the build process and should not be manually modified.
*   **`app/`**: This directory contains the application's source code. It includes the API routes, client components, and server components.
    *   **`api/`**: This directory contains the API routes for the application.
        *   **`posts/`**: This directory contains the API route for fetching blog posts.
            *   **`route.js`**: This file contains the route handler for fetching blog posts from the external API and caching them in Redis.
    *   **`client/`**: This directory contains the client components for the application.
        *   **`page.js`**: This file contains the main client component that renders the blog posts.
    *   **`page.js`**: This file contains the main server component that renders the blog posts.
*   **`lib/`**: This directory contains the utility library for the application.
    *   **`redis.js`**: This file contains the Redis client and connection logic. It exports a function called `getRedisClient` that returns an instance of the Redis client.
*   **`jsconfig.json`**: This file is the JavaScript configuration file. It is used to configure the JavaScript language service and provide hints to the editor.
*   **`next.config.js`**: This file is the Next.js configuration file. It is used to configure various aspects of the Next.js application, such as the build process, routing, and environment variables.
*   **`package-lock.json`**: This file is an npm package lock file. It records the exact versions of the dependencies used in the project.
*   **`package.json`**: This file is the npm package file. It contains metadata about the project, such as the name, version, and dependencies.
*   **`postcss.config.js`**: This file is the PostCSS configuration file. It is used to configure PostCSS, a tool for transforming CSS with JavaScript.
*   **`README.md`**: This file is the project documentation file. It provides an overview of the project, instructions for setting it up and running it, and other relevant information.

## Setup and Installation

To set up and run the application, follow these steps:

1.  **Clone the repository**:

    ```
    git clone <repository_url>
    cd <repository_name>
    ```

2.  **Install dependencies**:

    ```
    npm install
    ```

3.  **Set up environment variables**:

    Create a `.env.local` file in the root directory of the project and add the following environment variables:

    ```
    REDIS_URL=redis://default:YOUR_REDIS_PASSWORD@redis-14740.c264.ap-south-1-1.ec2.redns.redis-cloud.com:14740
    ```

    Replace `YOUR_REDIS_PASSWORD` with the actual password for your Redis instance. If you don't have redis instance, then you can get one for free over [here](https://redis.com/try-free/).

4.  **Run the application**:

    ```
    npm run dev
    ```

    This will start the Next.js development server. Open your browser and navigate to `http://localhost:3000` to view the application.

## Performance Benchmarking

To evaluate the performance improvements achieved by implementing Redis caching, the following metrics were measured:

*   **Page Load Time (without caching)**: The time it takes for the page to load when the data is fetched directly from the external API.
*   **Page Load Time (with caching)**: The time it takes for the page to load when the data is retrieved from the Redis cache.

The tests were conducted using Chrome DevTools in a local development environment. The cache was cleared before each test run to ensure accurate results. The average of multiple measurements was taken to calculate the final metrics.

The results are summarized in the following table:

| Metric               | Without Caching (Average) | With Caching (Average) |
| :------------------- | :------------------------ | :--------------------- |
| Page Load Time (ms) | 1170                      | 185                    |

The screenshots of the performance metrics from Chrome DevTools are provided below:

* **Without Caching**:  
  ![Without Caching](https://media.discordapp.net/attachments/1328425415848497253/1364824358492573758/Screenshot_2025-04-24_at_9.40.05_AM.png?ex=680b133c&is=6809c1bc&hm=d1de043674ebfb609e9c12ab7bd5af7f811b8727399b17e9268ff878812dd3b8&=&format=webp&quality=lossless&width=3046&height=1900)

* **With Caching**:  
  ![With Caching](https://media.discordapp.net/attachments/1328425415848497253/1364824359151075368/Screenshot_2025-04-24_at_9.40.21_AM.png?ex=680b133c&is=6809c1bc&hm=ca8830e8b870e23bc8fd9749ef1d3c8d34deb56f7a6c4596af1fff1a88144cd5&=&format=webp&quality=lossless&width=3028&height=1900)


The results clearly demonstrate a significant performance improvement with Redis caching. The page load time decreased from 1.17 seconds to 185 milliseconds after implementing caching, resulting in a reduction of approximately 84%. This improvement translates to a faster and more responsive user experience.

## Architecture Summary

The application follows a simple three-tier architecture:

1.  **Presentation Tier**: The Next.js components are responsible for rendering the user interface and handling user interactions. These components fetch data from the API tier and display it to the user.
2.  **API Tier**: The Next.js API routes handle requests from the presentation tier. These routes fetch data from the external API (dummyjson) and cache it in Redis.
3.  **Data Tier**: The Redis database stores the cached data. This allows the API tier to quickly retrieve frequently accessed data without having to make repeated requests to the external API.

The interaction between these tiers is as follows:

1.  When a user requests a page, the Next.js component in the presentation tier makes a request to the API tier.
2.  The API tier checks if the requested data is available in the Redis cache.
3.  If the data is found in the cache, it is returned to the presentation tier.
4.  If the data is not found in the cache, the API tier fetches it from the external API, stores it in the Redis cache, and returns it to the presentation tier.
5.  The presentation tier renders the data and displays it to the user.

## Scalability Vision

To scale this application to handle a large number of users, the following strategies can be implemented:

1.  **Horizontal Scaling**: The Next.js application and the Redis database can be scaled horizontally by adding more instances. This will distribute the load across multiple servers and improve the overall performance and availability of the application. Load balancers can be used to distribute traffic across the instances.

2.  **Microservices**: The application can be decomposed into smaller, independent microservices. For example, the data fetching and caching logic can be separated into a dedicated microservice. This will allow each microservice to be scaled and deployed independently, improving the overall flexibility and maintainability of the application.

3.  **Content Delivery Network (CDN)**: A CDN can be used to cache static assets, such as images and CSS files. This will reduce the load on the application servers and improve the page load times for users who are geographically distributed.

By implementing these strategies, the application can be scaled to handle a large number of users and provide a consistently fast and responsive user experience.
